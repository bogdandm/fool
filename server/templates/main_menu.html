<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fool | Главное меню</title>
    <script src="../static/js/jquery-2.1.4.min.js"></script>
    <script src="../static/js/jquery.mousewheel.min.js"></script>
    <script src="../static/js/jquery.mCustomScrollbar.concat.min.js"></script>
    <link href="../static/css/jquery.mCustomScrollbar.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=PT+Sans&subset=latin,cyrillic,cyrillic-ext' rel='stylesheet'
          type='text/css'>
    <link href="../static/css/global.css" rel="stylesheet" type="text/css">
    <link href="../static/css/buttons.css" rel="stylesheet" type="text/css">
    <link href="../static/css/menu.css" rel="stylesheet" type="text/css">
    <script>
        $(function () {
            $(".selector").add(".menu > .selection").add(".container").add(".container-mini").hide();

            $(".menu-item").hover(function () { // Перемещение блока выбора
                $(".selector").filter('[group="' + $(this).attr('group') + '"]').show().css({
                    top: $(this).position().top + "px"
                });
            }, function () {
            });

            var x = $("#main-menu");
            x.find("> .menu-item[container-name]").click(function () { // Клик по выпадающему элементу
                $(".menu > .selection").css({
                    top: $(this).position().top + 'px'
                }).show();
                $(".container").add(".container-mini").filter(':not(#' + $(this).attr('container-name') + ')').hide();
                $("#" + $(this).attr('container-name')).toggle().filter('.container-mini').css({
                    top: $(this).position().top + 'px'
                })
            });

            x.find("> .menu-item:not([container-name])").click(function () { // Клик по не выпадающему эл-ту
                $(".menu > .selection").add(".container").add(".container-mini").hide();
            });

            x.find("> .menu-item").click(function () { // Псевдо-клик по блоку выбора
                var self = this;

                function f() {
                    $(".selector").filter('[group="' + $(self).attr('group') + '"]').css({
                        backgroundColor: "rgba(155, 237, 47, 0.5)"
                    });
                }

                $(".selector").filter('[group="' + $(this).attr('group') + '"]').css({
                    backgroundColor: "rgba(155, 237, 47, 0.8)"
                });

                setTimeout(f, 200);
            });

            $('#logout').click(function () {
                $.ajax({
                    url: "/api/destroy_session",
                    success: function () {
                        window.location.href = '/static/login.html';
                    }
                });
            });
        })
    </script>
    <style>
        main {
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: flex-start;
            height: calc(100% - 60px);
        }

        .container {
            position: relative;
            height: 100%;
            width: calc(100% - 300px);
            z-index: -10;
            padding: 10px;
        }

        .container-mini {
            position: relative;
            top: 41px;
            z-index: -10;
        }

        .container-mini > .menu {
            width: 400px;
            margin-left: 0;
        }

        .container-mini > .menu > .menu-item:last-child {
            border-bottom: none;
        }

        .menu {
            width: 300px;
            min-width: 300px;
        }

        .user_name {
            padding-top: 8px;
        }
    </style>
</head>
<body>
<header>Дурак online</header>
<main>
    <div id="main-menu" class="menu standard-box">
        <div class="selector" group="1"></div>
        <div class="user_name" group="1">{{ user_name }}</div>
        <div class="menu-item" group="1" container-name="new-games">Новая игра</div>
        <div class="menu-item" group="1" container-name="friends">Друзья (coming soon)</div>
        <div class="menu-item" group="1">Статистика (coming soon)</div>
        <div id="logout" class="menu-item" group="1">Выйти из аккаунта</div>
        <div class="selection"></div>
    </div>
    <div id="new-games" class="container-mini">
        <div class="menu standard-box">
            <div class="selector" group="2"></div>
            <div class="menu-item" group="2"><a href="arena?mode=1">Игра против другого игрока</a></div>
            <div class="menu-item" group="2"><a href="">Играть с другом</a></div>
            <div class="menu-item" group="2"><a href="arena?mode=0">Играть против ИИ</a></div>
        </div>
    </div>
    <div id="friends" class="container standard-box mCustomScrollbar"
         data-mcs-theme="minimal-dark">

        You can drop the Cloth & Chain cluster soon as you have enough res on gear. It's just a nice cluster
        that gives quite a bit of armor and res early on while not being terribly out of the way.

        Current gear will allow me to swap out my Daresso's for a Lightning Coil I just haven't bought a 6 link
        one yet. The only required gear for the build to work are Soul Taker and Jack the axe. Everything else
        is supplementary. You can make this build for under 3 exalts or spend as much as you like with Lightning
        Coil + Headhunter as long term goals.

        The skill tree is pretty flexible you can pick up some extra stat nodes if you can't get the stats on
        gear. You can also pick up a 5th Endurance charge if your gear is lacking in defense.

        For jewels. You want to focus on stacking phys damage, attack speed and life. High attack speed is
        really powerful in conjunction with the massive damage we get from Bloodlust but it's really preference.

        You can do any map mods with this build. I personally choose to avoid Blood Magic just because I like my
        auras, but its easily doable with a little more caution and potion management. For exceptionally hard
        mods you can swap out Herald of Ashe + AA for Grace, or if the map is ElE weakness you can use Purity of
        Elements.

        I prefer to use the Punishment Curse however Vulnerability is really powerful and probably better
        because it doesn't require a monster to physically attack you to trigger the buff and it also double
        dips and causes our bleed from Jack to do even more damage. You can however use any curse you like. Temp
        Chains, Enfeeble, Vulnerability, or Punishment.

        Sadly the Fortify Buff http://pathofexile.gamepedia.com/Fortify isn't shown on your character sheet but
        this build has 100% uptime on Fortify granting us an additional 20% reduced damage taken from all hits
        100% of the time! Excluding damage over time effects.

        The build also has a passive 17% chance to block and in my case 6% chance to dodge. You could obviously
        choose to use a Rumi's Concoction for another 20 - 30% additional block and 10 - 15% spell block. Giving
        you 47% chance to block on top of your already stacked defenses.
        ЛАБОРАТОРНАЯ РАБОТА
        Тема: Приложения с графическим интерфейсом
        Цель работы: Освоить основным приемам работы с оконными объектами, создаваемыми приложениями.
        Библиотека Swing
        Современные прикладные программы предлагают пользователям графический интерфейс (GUI), который строится из
        управляющих элементов, т.е. кнопок, флажков, списков и т.п. Чтобы обеспечить эту возможность, системы
        программирования предлагают разработчикам наборы готовых классов и интерфейсов в виде библиотек.
        Для создания графического интерфейса пользователя в Java используются библиотеки визуальных компонентов. Самая
        ранняя из них называется AWT (Abstract Widow Toolkit). Позже была разработана библиотека Swing, которая
        сохранила некоторые принципы функциональности, заложенные в AWT, но предлагала более эффективные и гибкие
        реализации управляющих элементов.
        Иерархия оконных классов
        Для оконных объектов в Java определена иерархия, базовые классы которой помещены в пакет java.awt.
        • Компоненты.
        На вершине иерархии находится класс Component (наследник Object) Все элементы пользовательского интерфейса
        наследуют Component и поэтому также являются компонентами. В классе определены основные свойства и методы,
        необходимые элементам интерфейса (прорисовка собственного графического представления, изменения размеров и
        положения окон, обработка ввода с клавиатуры, управление фокусом, взаимодействие с мышью и др).
        • Контейнеры.
        Компоненты, которые могут содержать другие компоненты, называются контейнерами. Контейнеры создаются как объекты
        класса Container. Этот класс — прямой наследник Component. Поэтому контейнеры, наряду с элементами интерфейса,
        являются компонентами. Благодаря этому в контейнер можно добавлять другие контейнеры и тем самым выстраивать
        иерархию контейнеров.
        В классе Container определены методы, позволяющие эффективно управлять коллекцией компонентов в контейнере.
        Некоторые из них:
        add(Component cmpnt) — добавляет в контейнер компонент cmpnt;
        remove(Component cmpnt) — удаляет из контейнера компонент cmpnt;
        removeAll() — удаляет все элементы из контейнера;
        getComponentCount() — возвращает количество элементов в контейнере.
        С помощью объектов, реализующих интерфейс LayoutManager, объекты класса Container управляют стратегией взаимного
        расположения компонентов, находящихся в контейнере, при выводе в окно приложения.
        • Панели и окна.
        На следующем уровне иерархии оконных классов находятся два класса: Panel и Window.
        Класс Panel — конкретный класс, поэтому можно создавать его объекты. От класса Container панели, как контейнеры,
        наследуют возможность методом add помещать в контейнер другие компоненты. А с помощью методов move, resize и
        reshape, унаследованных от класса Component, задавать положение компонентов или изменять размер. По умолчанию
        для панелей применяется менеджер компоновки FlowLayout.
        Оконные свойства класса Panel наследуют объекты его подкласса Applet. А в java-приложениях объекты класса Panel
        обычно используются как промежуточные контейнеры, в которые можно поместить часть компонентов, которыми нужно
        управлять отдельно. Например, можно создать панель, составленную из набора кнопок.
        Класс Window определяет окна верхнего уровня, у которых не прорисовываются границы, нет меню и заголовков. Из-за
        этого в программах объекты самого класса Window для создания окон используются редко. По умолчанию для окон
        этого типа применяется менеджер компоновки BorderLayout.
        • Фреймы.
        Для окон java-приложений используются объекты класса Frame, являющегося подклассом Window. Этот класс,
        представляет окна верхнего уровня, которые имеют заголовок, граничный контур и возможность добавления строки
        меню.
        Хотя окна фреймов имеют кнопку "крестик", по умолчанию они никак не реагируют на попытку пользователя закрыть
        окно. Чтобы можно было завершать приложение, программист должен подготовить специальный обработчик этого
        события, в котором предусмотрен вызов System.exit(0).
        Класс JFrame
        У JFrame, наследника класса Frame, поведение при попытке закрытия окна реализовано иначе — объект JFrame по
        умолчанию становится невидимым, но продолжает функционировать и при необходимости его можно будет опять
        прорисовать.
        Чтобы управлять поведением программы при попытке пользователя закрыть окно, используется метод
        setDefaultCloseOperation(int).
        Значения аргумента задаются специальными константами, определенными в интерфейсе WindowConstants, который
        реализуется классом JFrame (поэтому константы доступны в классе JFrame и его потомков без ссылок на
        WindowConstants):
        EXIT_ON_CLOSE — завершить приложение,
        HIDE_ON_CLOSE — скрыть окно (поведение по умолчанию JFrame),
        DISPOSE_ON_CLOSE — ресурсы, выделенные окну, освобождаются, но приложение продолжает работать,
        DO_NOTHING_ON_CLOSE — ничего не делать, когда пользователь пытается закрыть окно (поведение по умолчанию окон
        типа Frame),
        Например, чтобы объект JFrame закрывал приложение, нужно добавить в его класс или выполнить для объекта вызов
        метода
        setDefaultCloseOperation(EXIT_ON_CLOSE).
        Замечание.
        Перечисленные выше константы наследуются классом JFrame, поэтому при необходимости к ним можно обращаться как к
        статическим полям этого класс.
        Перед отображением окна, необходимо совершить больше действий, чем это кажется на первый взгляд. Даже при
        разработке простых программ потребуется использовать несколько методов класса JFrame. Некоторые из них приведены
        ниже.
        JFrame() — конструктор без параметров создает пустое окно.
        JFrame(String title) — конструктор создает пустое окно с заголовком title.
        setSize(int width, int height) — устанавливает размеры окна (в пикселах, без указания единиц измерения). Если не
        задать размеры, окно будет иметь нулевую высоту независимо от того, что в нем находится. Будет видна только
        полоса заголовка окна с кнопками. Чтобы увидеть содержание окна, пользователю придется растягивать его вручную.
        setVisible(boolean visible) — когда создается окно, оно по умолчанию невидимо. Если метод setVisible вызван со
        значением true, то окно прорисовывается, а, если со значением false, — то вновь становится невидимым.
        Некоторые принципы создания GUI
        При использовании оконных классов нужно помнить следующее.
        • В корне этой иерархии находится контейнер верхнего уровня, в который могут быть вложены компоненты и другие
        контейнеры.
        • Чтобы появиться на экране, каждый компонент GUI должен быть элементом, помещенным в иерархию контейнеров.
        • Каждый компонент GUI может быть помещен в контейнер только один раз. Если компонент уже находится в каком-то
        контейнере и делается попытка добавить его в другой контейнер, то он будет удален из первого и добавлен во
        второй контейнер.
        • Контейнер верхнего уровня рассматривается, как содержащий две "панели". В одну из них (Content Pane) помещены
        находящиеся в контейнере отображаемые компоненты GUI. Для получения объекта этой панели имеется метод
        getContentPane(), возвращающий объект контейнера Для добавления компонентов в этот контейнер используется метод
        add. В современных версиях Java синтаксис упрощен и можно обходиться без явного вызова getContentPane().
        Например, для окна myFrame вызов myFrame.getContentPane().add(...) будет эквивалентен более простому
        myFrame.add(...).
        • Вторая, отдельно хранящаяся панель, является необязательной — в контейнер верхнего уровня может быть добавлено
        меню окна. Хотя элементы меню помещаются в тот же контейнер верхнего уровня, что и графические компоненты
        интерфейса, они хранятся отдельно.
        Общая задача.
        В следующих заданиях предлагается последовательно разработать приложение, позволяющее открывать несколько окон
        (англ. multiple windows) и управлять их свойствами.
        ЗАДАНИЕ 1 (Создание окна)
        Разрабатывается приложение, в котором основной класс создает и отображает окно, являющееся объектом
        вспомогательного класса.
        1. Создать новый пустой проект с двумя классами:
        • основной MultipleWindows и
        • вспомогательный MyWindow.
        Вспомогательный класс может быть описан в отдельном файле проекта или в том же файле, что и основной.
        Замечание
        Gel имеет тип проекта "Приложения Swing", но при создании его скелета добавляет устаревший стиль обработки
        события закрытия окна. Кроме того, в заданиях не предполагается, что главный класс приложения является
        наследником JFrame. Поэтому предлагается выбрать пустой проект и наполнять его самостоятельно.
        2. Импортировать целиком пакет javax.swing.
        3. Объекты класса MyWindow — это окна типа JFrame, поэтому класс является наследником JFrame. Класс имеет
        конструктор с тремя параметрами: имя окна и два размера окна.
        В конструкторе MyWindow
        а) вызывается конструктор суперкласса с одним параметром — заголовком окна,
        б) назначаются размеры (метод setSize),
        в) назначается поведение при закрытии окна — закрыть приложение.
        4. В классе MultipleWindows реализуется только метод main. В нем
        а) создается объект типа MyWindow (параметры задать по своему усмотрению) и
        б) созданное окно делается видимым.
        Замечание
        В программе может использовать несколько окон. Поэтому логично, что какие из них должны быть видимы/невидимы,
        должен решать в основном классе, управляющим приложением, а не в конструкторе вспомогательного.
        5. Проверить работу программы.
        ЗАДАНИЕ 2 (Создание нескольких окон)
        Создается новый вариант класса MultipleWindows (предыдущий закомментировать).
        1. В классе определяются два поля:
        • переменная mw для хранения объекта окна MyWindow,
        • статическая переменная counter типа int, инициализируемая значением 1.
        2. Определяется два конструктора, в которых создаются объекты класса MyWindow, сохраняемые в переменной mw.
        а) В конструкторе MultipleWindows без параметров вызывается конструктор MyWindow со следующими значениями
        параметров: ширина и высота — 200, а заголовок окна склеивается из текста "Без имени " и значения переменной
        counter. После этого значение counter увеличивается на единицу.
        б) В конструкторе MultipleWindows с тремя параметрами (ширина, высота, заголовок) вызывается конструктор
        MyWindow, которому передаются три параметра.
        3. В классе определяется открытый метод
        void showMyWindow(Boolean visibility),
        который используется для визуализации/скрытия окна. В нем для объекта вызывается метод setVisible со значением
        параметра visibility.
        4. В методе main выполняются следующие действия.
        а) С использованием конструктора без параметров создается объект fw1 класса MultipleWindows. Окно,
        соответствующее этому объекту, делается видимым.
        б) С использованием конструктора создается второй объект fw2 класса MultipleWindows (параметры по своему
        усмотрению). Окно, соответствующее этому объекту, делается видимым.
        5. Проверить работу программы.
        6. Окна перекрываются, потому что оба расположены используют положение по умолчанию. Чтобы созданные окна можно
        было перемещать, в классе MultipleWindows определяется публичный метод
        void moveMyWindow(int horizontal,int vertical)
        аргументы которого задают позицию, в которую нужно переместить окно.
        В этом методе для оконного объекта вызывается унаследованный от класса Window метод setLocation(int x, int y), в
        котором указываются новые координаты левого верхнего угла окна.
        Добавить в main такое перемещение второго окна, чтобы окна не перекрывались.
        7. Приложение завершает работу при закрытии любого из окон. Однако в приложениях обычно должно быть окно,
        которое является главным, а остальные окна являются подчиненными ему. Закрывать приложение должно только главное
        окно.
        Чтобы реализовать это, нужно изменить конструктор окон класса MyWindow. Так как приложение может создать много
        окон, то логично для окон по умолчанию действия при попытке закрыть окно либо ничего не делать, либо скрывать
        окна, не завершая приложение.
        Для скрытия окон достаточно в конструкторе закомментировать строку с оператором
        setDefaultCloseOperation(EXIT_ON_CLOSE). Объяснить, почему этого достаточно.
        8. Чтобы можно было назначить окно главным, причем только одно, в классе MultipleWindows делаются следующие
        изменения.
        а) В класс добавляется статическое поле mainWindowExists булевского типа, инициализируемое значением false.
        б) Создается публичный метод для назначения главного окна
        void assignMainWindow(),
        в котором проверяется, назначено ли уже главное окно (значение mainWindowExists) .
        Если главное окно уже есть, то метод ничего не делает. Если его еще нет, то с помощью setDefaultCloseOperation
        для текущего оконного объекта назначется операция по умолчанию "закрытие окна" и меняется значение
        mainWindowExists на true.
        Проверить работу программы, назначив главным окно объекта fw2.
        В чем проблема? Как её избежать.
        ЗАДАНИЕ 3 (Назначение менеджера расположения)
        1. Добавить импорт всего пакет java.awt.
        2. В класс MultipleWindows добавляется публичный метод
        void addButton(JButton btn),
        в котором переданная через аргумент кнопка btn добавляется оконному объекту с помощью метода add.
        3. В методе main создать объект кнопки класса JButton (класс находится в пакете swing, поэтому он уже
        импортирован).
        В конструкторе объектов этого класса задается надпись, которая появится на кнопке.
        JButton btn = new JButton("Моя кнопка");
        Чтобы ясно видеть размеры кнопки, с помощью метода setBackground назначается цвет её фона. Цвета определены в
        классе java.awt.Color, который импортирован в составе пакета awt. Соответствующий код имеет вид:
        btn.setBackground(Color.YELLOW);
        Вызвать метод addButton для одного из окон и передать ему созданную кнопку.
        Объяснить результат работы программы.
        4. Для изменения менеджера расположения, добавить в класс MultipleWindows метод
        void changeLayout(LayoutManger lm);
        в котором для оконного объекта mw вызывается метод changeLayout, которому передается объект назначаемого
        менеджера потокового расположения.
        5. Для окна, в которое была помещена кнопка, изменить менеджер расположения на FlowLayout. Чтобы не создавать
        лишнюю переменную, создание объекта менеджера new FlowLayout() можно совместить с передачей аргумента методу
        changeLayout.
        6. Проверить работу программы. Объяснить результаты.
        Вопросы для самоконтроля
        1. Какая роль в иерархии оконных классов отводится классам Component и Container?
        2. Какими отличиями, связанными с закрытием окон обладают классы Frame и JFrame?
        3. Что происходит, если один и тот же компонент добавляется в два контейнера?
        4. Какие важные методы определены в классе Container?
        5. Какова структура хранения компонентов графического интерфейса и меню в оконном объекте?
        6. Каким образом выполняется управление видимостью окон? Что выполняется по умолчанию?
        7. Как можно задать или изменить положение окна?
        8. Каким образом задать конкретное поведение приложения Swing при закрытии окна? Какие варианты этого поведения
        существуют? Где определены константы, задающие эти варианты? Есть ли классы, которые наследуют их?
        9. Как заменить менеджер расположения, используемый для контейнера, в частности, у оконного объекта?
        10. Какой менеджер расположения по умолчанию используется объектами класса JFrame?


    </div>
</main>
</body>
</html>